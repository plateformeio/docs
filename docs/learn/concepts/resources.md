---
icon: symbols/resource
---

!!! construction "Work in progress..."

    This page is a work in progress, please check back later for updates.

!!! danger "AI generated content"

    This page was generated by an AI model trained on the original content and may not be fully accurate.

Resources are one of the core building blocks of the Plateforme framework. They represent your application's data models and business logic in a clean, declarative way while providing powerful features for validation, serialization, and database integration.

Resources can implement services to encapsulate reusable business logic and operations, allowing for separation of concerns. They also provide full integration with SQLAlchemy models, supporting all ORM features and database operations.

## Overview

A resource in Plateforme is a Python class that defines:

- The structure and validation rules for your data
- Database schema and relationships
- API endpoints and serialization rules
- Business logic through services and specifications

## Key concepts

### Resource definition

Resources are defined by inheriting from `BaseResource`:

```python
from plateforme import BaseResource, Field
from plateforme.types import Email

class User(BaseResource):
    username: str = Field(unique=True, max_length=100)
    email: Email = Field(unique=True)
    active: bool = Field(default=True)
```

### Field types and validation

Fields in a resource can use:

- Basic Python types (str, int, bool, etc.)
- Plateforme types (Email, UUID, etc.) 
- Pydantic and custom types
- Complex types (lists, dictionaries)
- Related resources

Each field can have validation rules defined through `Field()` options:

```python
from typing import Literal
from plateforme import BaseResource, Field

class Product(BaseResource):
    name: str = Field(min_length=1, max_length=200)
    price: float = Field(gt=0)
    category: Literal['books', 'clothing', 'electronics'] = Field(frozen=True)
```

### Resource configuration

Resources can be configured through their inner `__config__` attribute. It can be provided as a dictionary or a `ResourceConfig` object.

The `ConfigDict` class provides a convenient way to define configuration options, but you can also use a raw dictionary. Type hints should work with both approaches.

```python
from plateforme import BaseResource, ConfigDict

class User(BaseResource):
    __config__ = ConfigDict(
        title="User account",
        description="Represents a user in the system",
    )
    ...
```

### Database integration

Resources automatically map to database tables using the framework's database integration:

- Fields map to database columns with appropriate types
- Relationships between resources are inferred from type hints and handled through foreign keys
- Indexes and constraints are created based on field options
- Migration management is built-in (coming soon)

### Resource relationships

Resources can be related to each other through various types of relationships:

```python
from plateforme import BaseResource, Field

class Order(BaseResource):
    id: int = Field(unique=True)
    user: User = Field(linked=True)  # One-to-Many relationship
    products: list[Product] = Field(linked=True)  # Many-to-Many relationship
```

### Services and business logic

Resources can have associated services that implement business logic:

```python
from plateforme import BaseService, Key, route

class SomeService(BaseService):
    @route.get()
    async def hello(self) -> bool:
        ...
```

### CRUD operations

The `CRUDResource` class provides common database operations out of the box:

```python
from plateforme import CRUDResource, ConfigDict

class Product(CRUDResource):
    __config__ = ConfigDict(
        endpoints={'include_method': ['GET', 'POST', 'DELETE']},
    )
    ...
```

## Advanced features

### Computed fields

Resources can have computed fields that are calculated from other fields:

```python
from plateforme import BaseResource, computed_field

class Order(BaseResource):
    items: list[OrderItem]
    
    @computed_field
    @property
    def total_amount(self) -> Decimal:
        return sum(item.price * item.quantity for item in self.items)
```

### Field aliases

You can specify different names for fields in different contexts:

```python
from plateforme import BaseResource, Field

class User(BaseResource):
    given_name: str = Field(alias="first_name")
    family_name: str = Field(alias="last_name")
```

### Resource inheritance

Resources support inheritance for sharing common fields and behavior. Data can be stored in a single table or multiple tables based on the inheritance strategy configured in resource (see the `use_single_table_inheritance` property).

```python
import datetime
from plateforme import BaseResource

class AuditableResource(BaseResource, use_single_table_inheritance=True):
    # or use __config__ = ConfigDict(use_single_table_inheritance=True)
    created_at: datetime.datetime
    updated_at: datetime.datetime
    created_by: str
    updated_by: str

class Invoice(AuditableResource):
    code: str
    amount: float
```
